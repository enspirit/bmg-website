---
title: Overview
sidebar:
  order: 1
---

import { Badge } from '@astrojs/starlight/components';

## Relational Operators

Relational operators take relations as input and produce relations as output.

| Category | Operator | Description | Ruby | TS |
|----------|----------|-------------|:----:|:--:|
| **Selection** | [`restrict`](/reference/relational/restrict) | Filter tuples matching a predicate (aka `where`) | ✓ | ✓ |
| | [`exclude`](/reference/relational/exclude) | Filter tuples NOT matching a predicate | ✓ | ✓ |
| | [`matching`](/reference/relational/matching) | Semi join (where exists) | ✓ | ✓ |
| | [`not_matching`](/reference/relational/not-matching) | Inverse semi join (where not exists) | ✓ | ✓ |
| **Projection** | [`project`](/reference/relational/project) | Keep specified attributes only | ✓ | ✓ |
| | [`allbut`](/reference/relational/allbut) | Remove specified attributes | ✓ | ✓ |
| **Joining** | [`join`](/reference/relational/join) | Natural join on a join key | ✓ | ✓ |
| | [`left_join`](/reference/relational/left-join) | Left join with optional default tuple | ✓ | ✓ |
| | [`cross_product`](/reference/relational/cross-product) | Cross product (aka `cross_join`) | ✓ | ✓ |
| **Set Operations** | [`union`](/reference/relational/union) | Set union | ✓ | ✓ |
| | [`minus`](/reference/relational/minus) | Set difference | ✓ | ✓ |
| | [`intersect`](/reference/relational/intersect) | Set intersection | | ✓ |
| **Renaming** | [`rename`](/reference/relational/rename) | Rename some attributes | ✓ | ✓ |
| | [`prefix`](/reference/relational/prefix) | Add prefix to attribute names | ✓ | ✓ |
| | [`suffix`](/reference/relational/suffix) | Add suffix to attribute names | ✓ | ✓ |
| **Extension** | [`extend`](/reference/relational/extend) | Add computed attributes | ✓ | ✓ |
| | [`constants`](/reference/relational/constants) | Add constant attributes | ✓ | ✓ |
| | [`transform`](/reference/relational/transform) | Transform attribute values | ✓ | ✓ |
| **Summarization** | [`summarize`](/reference/relational/summarize) | Relational summarization (group by + aggregate) | ✓ | ✓ |
| **Structuring** | [`group`](/reference/relational/group) | Create relation-valued attribute from attributes | ✓ | ✓ |
| | [`ungroup`](/reference/relational/ungroup) | Flatten relation-valued attributes | ✓ | ✓ |
| | [`image`](/reference/relational/image) | Create relation-valued attribute from another relation | ✓ | ✓ |
| | [`wrap`](/reference/relational/wrap) | Wrap attributes into tuple-valued attribute | | ✓ |
| | [`autowrap`](/reference/relational/autowrap) | Structure a flat relation (e.g. split on `_`) | ✓ | ✓ |
| | [`unwrap`](/reference/relational/unwrap) | Merge tuple-valued attributes into parent tuple | ✓ | ✓ |
| **Pagination** | [`page`](/reference/relational/page) | Pagination with explicit ordering | ✓ | |

## Non-Relational Operators

Non-relational operators take relations as input but produce other values (tuples, arrays, booleans, objects).

| Operator | Description | Ruby | TS |
|----------|-------------|:----:|:--:|
| [`one`](/reference/non-relational/one) | Extract single tuple from relation | | ✓ |
| [`toArray`](/reference/non-relational/to-array) | Convert relation to array (Ruby: `to_a`) | ✓ | ✓ |
| [`isEqual`](/reference/non-relational/is-equal) | Check set equality of two relations | | ✓ |
| [`yByX`](/reference/non-relational/ybyx) | Create mapping object from relation (Ruby: `y_by_x`) | ✓ | ✓ |

## Suppliers and Parts

Some examples for the individual operations available in Bmg use a version of the well-known [Suppliers and Parts database](https://en.wikipedia.org/wiki/Suppliers_and_Parts_database). It contains the following four relations:

##### cities
| city     | country |
|----------|---------|
| London   | England |
| Paris    | France  |
| Athens   | Greece  |
| Brussels | Belgium |

##### parts
| pid | name  | color | weight | city   |
|-----|-------|-------|--------|--------|
| P1  | Nut   | Red   | 12.0   | London |
| P2  | Bolt  | Green | 17.0   | Paris  |
| P3  | Screw | Blue  | 17.0   | Oslo   |
| P4  | Screw | Red   | 14.0   | London |
| P5  | Cam   | Blue  | 12.0   | Paris  |
| P6  | Cog   | Red   | 19.0   | London |

##### suppliers
| sid | name  | status | city   |
|-----|-------|--------|--------|
| S1  | Smith | 20     | London |
| S2  | Jones | 10     | Paris  |
| S3  | Blake | 30     | Paris  |
| S4  | Clark | 20     | London |
| S5  | Adams | 30     | Athens |

##### supplies
| sid | pid | qty |
|-----|-----|-----|
| S1  | P1  | 300 |
| S1  | P2  | 200 |
| S1  | P3  | 400 |
| S1  | P4  | 200 |
| S1  | P5  | 100 |
| S1  | P6  | 100 |
| S2  | P1  | 300 |
| S2  | P2  | 400 |
| S3  | P2  | 200 |
| S4  | P2  | 200 |
| S4  | P4  | 300 |
| S4  | P5  | 400 |

Here's are some examples to illustrate what the relations represent:

* Supplier S1 (Smith) supplies 6 different parts
* There are 2 types of screw, one which weighs 17.0 and the other 14.0 (grams, let's say)
* There are 2 suppliers in London, 2 in Paris, and 1 in Athens
* Supplier S4 (Clark) has 900 parts in stock, in total
* For the part P5 (Cam), there are 500 items in stock in total, accross all suppliers

Our examples assume the four relations are referenced by variables by the same names: `cities`, `parts`, etc.


Get part numbers for all parts supplied by more than one supplier
